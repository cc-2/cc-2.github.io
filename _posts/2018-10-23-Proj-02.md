---
layout: post
title: "Proyecto 2: Mail Server"
comments: true
date:   2018-10-23 11:58:00 -0600
category: proyectos
numero: 2
descripcion: >
 Proyecto 2: Implementación de un cliente y servidor que simulan el funcionamiento de correo electrónico.
---

# Mail Client/Server
* Tema: Programación orientada a objetos, estructuras de datos, redes, threads.
* Fecha de entrega: PENDIENTE
* Grupo de trabajo: Cuatro personas, divididos en dos subgrupos de dos personas.
* Calificación personal: PENDIENTE

Este es el proyecto final del curso, por lo que se espera que usted ponga todo su esfuerzo en realizarlo, para demostrar los conocimientos que adquirió durante todo el semestre. El propósito del proyecto es que usted aplique todos los conceptos aprendidos y desarrolle un software completo utilizando como herramienta el lenguaje de programacion Java.

Además de implementar lo que se le pida, debe cumplir con las siguientes especificaciones para que su proyecto sea considerado como válido:

* El lenguaje de programación a utilizar para la implementación debe ser Java.
* Por el tipo de proyecto DEBE implementar una interfaz gráfica. Para este proyecto se le pide que utilice JFrames, NO APPLETS.
* Debe utilizar la o las estructuras de datos vistas en clase que mas le ayuden a guardar los datos requeridos. DEBE de utilizar las clases que Java le provee para esto.
* Para la conservación de los datos ingresados durante la ejecucion del programa, usted tiene que utilizar una base de datos, de tal forma que cuando se vuelva a ejecutar ya utilice datos guardados en ella. Se le explicara más adelante como la debe utilizar.
* Su comunicación debe ser cliente-servidor-cliente, no puede ser solo cliente-cliente.

En este proyecto consiste en implementar una aplicación (cliente-servidor) para un servicio de correo electrónico. Su proyecto, en general, debe permitir a un usuario mandar emails a contactos que pertenezcan al mismo servidor, y a contactos en otros servidores.
La aplicacion estará dividida en un programa cliente y un programa servidor, los cuales se comunicaran entre sí utilizando un protocolo de comunicacion definido por nosotros. Dicha comunicacion sólo sera permitida entre cliente-servidor, y/o servidor-servidor.

## Programa Cliente
El programa cliente es el encargado de brindar una interfaz al usuario, en la cual pueda hacer las siguientes tareas:

* Manejo de contactos: El usuario debe ser capaz de ingresar contactos nuevos (para hacerlo mas simple, solo se guarda la dirección de correo del contacto), y ver la lista de contactos que tiene.
* Lectura de correos: El usuario debe ser capaz de poder leer los correos que le han enviado. Tanto los correos nuevos, como los ya leidos anteriormente.
* Envio de correos: El usuario debe ser capaz de enviar correos a cualquiera de sus contactos. El correo puede tener uno o más destinatarios.

## Programa Servidor
El programa servidor es el encargado de proveer el servicio de envío de correos entre usuarios del mismo servidor, y desde/hacia usuarios de otros servidores. Dado que es una aplicacion cliente-servidor, para que un programa cliente envíe un correo lo debe hacer a través del servidor (solicitándole al servidor que envie el correo al respectivo contacto), el cual se comunicará con el programa cliente o servidor respectivo y enviará la informacion.

Cada grupo tendrá que implementar un programa cliente y un programa servidor para esta aplicación. Los grupos se dividirán en dos subgrupos, un subgrupo se encargará de hacer el cliente, y otro subgrupo se encargará de hacer el servidor.
Uno de los objetivos de el proyecto, es que cualquier cliente perteneciente a cualquier servidor debe poder interactuar (mandar correos) hacia cualquier otro cliente perteneciente a cualquier otro servidor. Para esto, definimos un protocolo de comunicacion, tanto para el programa cliente, como para el programa servidor. 

## Especificaciones y Protocolo de Comunicación
A continuación se describe el protocolo completo de comunicación de un cliente y un servidor. Asegurese de seguirlo al pie de la letra para que pueda comunicarse sin problema con cualquier otro servidor o cliente. Dentro de la definición del protocolo, también se le dan especificaciones de la funcionalidad que se requiere en el proyecto.

## Comunicación cliente-servidor
La comunicación entre cliente y servidor se hará a base de comandos escritos en strings. Dado que su servidor o cliente debe poder comunicarse con servidor o cliente de otro grupo, deben asegurarase de mandar por la red strings y no otro tipo de dato, de la misma forma deben asegurarse de no enviar espacios o newlines adicionales. Los comandos del servidor son descritos en esta parte. Se describen también los comandos de respuesta del servidor, así que este atento a quién emite cada uno.

### Login
Al iniciar el programa cliente, este debe permitir al usuario hacer login al servidor. El cliente debe leer del usuario el username, el nombre del servidor al que se va a comunicar y su password (el password no debe ser visible al usuario). El usuario ingresa su servidor de la siguiente manera:
```
usuario@servidor
```

Su servidor puede tener el nombre que ustedes quieran. El cliente debe separar este string en dos partes: nombre de usuario y nombre de servidor. El cliente debe tener una tabla de IPs de servidores, y debe verificar que el servidor ingresado se encuentre en esta tabla. Si el servidor sí se encuentra, el cliente abrirá una conexión hacia ese servidor en específico y mandará el comando para login:
```
LOGIN username password
```

Al recibir este comando, el servidor debe realizar una serie de operaciones:
1. Primero debe verificar que el username se encuentre en su tabla de usuarios. Si no se encuentra, el server debe responder con un error. (Los errores se explican al final)
2. Ya que se verificó que el usuario exista, se compara el password.
3. Si el password es válido entonces se manda al cliente la siguiente respuesta:
```
OK LOGIN
```
Esta le indica al cliente que el usuario existe y que su login está autorizado. El servidor debería marcar al usuario como logged in.
4. Si el password no es válido, el server debee responder con un error. 

Después de recibir el `OK LOGIN` del servidor, el cliente debe solicitar la lista de contactos del usuario (la cual está guardada en el servidor) con la instrucción:
```
CLIST username
```

El servidor debe responder con una o varias instrucciones, ya que es una lista de uno o varios contactos. Cuando se manda un contacto que NO es el ultimo en la lista el server manda un mensaje de la forma:
```
OK CLIST contact@server
```
Donde `contact` es el nombre de usuario del contacto, y `server` el servidor al que pertenece el contacto.

Si el contacto es el ultimo en la lista, entonces la instruccion sería:
```
OK CLIST contact@server *
```
Donde el `*` le indica al cliente que ese es el final de la lista de contactos. Note que existe un espacio entre la información del contacto y el asterisco.

Luego de obtener el listado de contactos se deben solicitar los correos nuevos, si hay alguno. Esto se hace con la instrucción:
```
GETNEWMAILS username
```

El servidor responderá a este comando con la lista de correos nuevos, o un mensaje que indique que no existen correos. Si existen correos, el servidor responderá de la siguiente manera:
```
OK GETNEWMAILS sender subject body
```

En donde `sender` es el correo del contacto que mandó el correo, `subject` es el asunto del correo, y `body` es el contenido del correo. Como el asunto y el contenido del correo pueden tener varias palabras, estos deberán encerrarse entre comillas (ver ejemplo abajo). Dado que pueden haber varios correos nuevos, para indicar que es el último correo se agregará `*` al final del mensaje, de la siguiente manera:
```
OK GETNEWMAILS sender subject body *
```

Si no hay correos nuevos, el servidor responderá con la instrucción:
```
OK GETNEWMAILS NOMAILS
```

La solicitud de correos nuevos se realizará cuando el usuario haga login, pero también debe realizarse cada vez que el usuario quiera refrescar su lista de correos. El servidor NO manda los correos automáticamente al cliente en cuanto estos lleguen, solamente los manda cuando el cliente lo solicita.

Cuando se hayan recibido el listado de contactos y los correos nuevos, termina el proceso de login del cliente.

### Ejemplo de login exitoso
```
Client : LOGIN andrea password
Server : OK LOGIN
Client : CLIST andrea
Server : OK CLIST contact1@server1 
Server : OK CLIST contact2@server2 
Server : OK CLIST contact3@server3 *
Client : GETNEWMAILS andrea
Server : OK GETNEWMAILS xxx@server1 "Hola" "Hola, como estas? Nos vemos pronto"
Server : OK GETNEWMAILS yyy@server2 "Cumple Sofia" "Hola a todos, Nos reuniremos en casa de Sofia" *
```

### Envío de correos
Para mandar un correo a algún contacto, el cliente debe mandar la información del correo al servidor. Este se encargará de mandarlo al contacto o servidor indicado. Para enviar el correo, el cliente debe enviar las siguientes instrucciones seguidas.
```
SEND MAIL
MAIL TO contacto1@servidor1
MAIL TO contacto2@servidor2 *
MAIL SUBJECT text
MAIL BODY text
END SEND MAIL
```
`SEND BODY` indica que se empieza a enviar un correo. 

`MAIL TO contact@server` indica un destinatario del correo. Si hay varios destinatarios el último lleva `*` para indicar que es el último; si solo hay un destinatario este lleva `*`.

`MAIL SUBJECT text` y `MAIL BODY text` indican el asunto y contenido del correo respectivamente. Como pueden ser varias palabras, estas deben encerrarse entre comillas.

`END MAIL` indica que ya se envió toda la información necesaria.

En caso que se hayan recibido los datos y sean todos válidos, se responderá con la siguiente instrucción. (Los posibles errores se mencionan abajo).
```
OK SEND MAIL
```

### Nuevos correos
Para poder agregar un nuevo contacto, este se ingresaará en la forma `contact@server`. El cliente antes de poderlo agregar debe verificar su existencia entonces debe mandar la siguiente instruccion al servidor:
```
NEWCONT contact@server
```

El servidor verifica que el contacto sí exista. Si existe, responderá al cliente con la instrucción:
```
OK NEWCONT contact@server
```

Si el contacto existe, este se agregará al listado de contactos del usuario actual. Si el contacto no existe se reportará un error (más abajo). Si el contacto no pertenece a nuestro servidor, se deberá preguntar al servidor correcto (más abajo).

### NOOP y logout
Cuando el usuario va a hacer logout del cliente, el cliente debe mandar un aviso al servidor para que el servidor cierre la sesión con ese cliente, y actualice el estado del usuario a offline:
```
LOGOUT
```

Para que el cliente pueda cerrar la sesion, el servidor debe mandarle un mensaje:
```
OK LOGOUT
```

Tras recibir este mensaje, el cliente puede cerrar la sesión. Si no lo recibo NO puede cerrar la sesión.

NOOP es una abreviatura para No Operation. Esta instrucción sirve para que el servidor sepa que el cliente todavia esta vivo, es decir que el cliente todavia esta conectado. Si el servidor no recibe este NOOP cada cierto tiempo (que pasa sin que el cliente haga nada) entonces el servidor cierra la conexión, ya que no esta seguro que el cliente siga activo. Esto es para evitar que el servidor mantenga conexiones abiertas que no son utilizadas porque el cliente se desconectó.

Cuando decimos que el cliente murió o se desconectó nos referimos a que el programa se cerró o la computadora se apagó por alguna razón, sin haber hecho un logout exitoso antes. Cuando esto sucede la conexión cliente-servidor sigue abierta en vano, por lo que deberá cerrarse.

El NOOP se debe mandar cada 20 segundos (20000 milisegundos) después del último comando. Cada comando que se mande o se reciba inicializa el contador del tiempo, y cuando el tiempo llegue a 20000 entonces se manda un NOOP:
```
NOOP
```

El servidor responderá al cliente para indicarle que este también sigue vivo:
```
OK NOOP
```

## Comporamiento del servidor
Usualmente, el servidor responde a las peticiones del cliente o de otro servidor. En esta parte le explicaremos como debe actuar el servidor con respecto a cada comando recibido ya sea del cliente o de otro servidor.

### LOGIN username password
Este comando es mandado por el cliente para hacer un login de un usuario especifico. Dentro de el servidor existe una tabla de usuarios existentes con su password, y el estado en el que se encuentran (online/offline). Lo primero que debe hacer el servidor es buscar si el usuario existe. 

Si no existe debe mandar al cliente el comando de error 101, que representará el error "unknown user":
```
LOGIN ERROR 101
```

Si el usuario si existe, entonces compara el password que está guardado en la tabla con el recibido en el comando. Si el password NO es igual entonces el servidor manda al cliente el comando de error 102, que representará "invalid password":
```
LOGIN ERROR 102
```

Si el password es correcto, entonces el servidor debe cambiar el estado del usuario a online y mandar al cliente la respuesta:
```
OK LOGIN
```

### CLIST username
Este es el comando de solicitud de lista de contactos por un cliente. Al recibir el servidor el esta petición, debe buscar los contactos asociados con ese usuario. 

Si no hay ningun contacto asociado con el usuario el servidor debe mandar el comando de error 103, que representa "no contacts found" (esto en realidad es un warning y no un error):
```
CLIST ERROR 103
```

Si existe algun contacto entonces el servidor debe alguno de los siguientes comandos:
```
OK CLIST contact@server
OK CLIST contact@server *
```
Recuerde que el `*` representa al último contacto en la lista.

### SEND MAIL
Esta es el comando que manda el cliente cuando quiere avisarle al servidor que esta por mandar informacion de un email. El servidor debe esperar a recibir el `END SEND MAIL` para analizar la información de correo que el cliente mandó.

Una de las cosas que el servidor debe hacer, es verificar que él o los destinatarios existan. Si el contacto es del mismo servidor, esto lo haría revisando la tabla de usuarios. Si el contacto es de otro servidor, tiene que preguntar a ese servidor si ese contacto existe (esto lo discutiremos más adelante). Si el contacto no existe, entonces debe mandar al cliente el error 104, que representa "unknown contact":
```
SEND ERROR 104 contact@server 
```

Si el contacto era de otro servidor y este no se pudo comprobar porque el servidor no existe o no estaba conectado, se responderá con el error 105, que representa "unknown server":
```
SEND ERROR 105 contact@server 
```

Si el usuario no colocó destinatario se responderá con error 106, "no recipients":
```
SEND ERROR 106
```

También se tienen los errores 107, "no subject", y error 108, "no body", en caso que el usuario no haya colocado esos datos:
```
SEND ERROR 107
SEND ERROR 108
```

### NEWCONT contact@server
Este comando nos indica que el usuario quiere agregar un nuevo contacto. Antes de agregar un nuevo contacto el servidor debe asegurarse que el contacto realmente exista. Si el contacto es local, debe buscarlo en su tabla de usuarios, si no lo encuentra, entonces responderá con error 109, "contact not found":
```
NEWCONT ERROR 109 contact@server
```

Si el contacto no es local, entonces hay que verificar con el servidor correspondiente. Si el servidor no existe o no está activo, se enviará al cliente el error 110, que indica "server not found":
```
NEWCONT ERROR 110 contact@server
```

Si el contacto existe, entonces se responderá al cliente:
```
OK NEWCONT contact@server
```

### NOOP
NOOP es la instrucción No Operation, que el cliente usa para indicarle al servidor que aún está vivo. Al recibirla, el servidor debe reiniciar el contador del tiempo del cliente, y mandar una respuesta:
```
OK NOOP
```
Esto le indica al cliente que el servidor recibió el mensaje y que este también está vivo.

# PENDIENTE

COMUNICACION SERVIDOR-SERVIDOR

El servidor no solo debe comunicarse con los clientes, sino tambien con otros servidores para hacer posible el envio de emails entre usuarios que pertenecen a diferentes servidores.

Mas adelante hablaremos de como sabe el server que servidor existen y cuales son sus ips, por el momento supondremos que el servidor ya tiene una tabla con los ips y nombres de los servidores que estan online en este momento.
La comunicacion entre servidor y servidor, se reduce a envio de emails y chequeo de contactos existentes.

SEND MAIL contact@server
Este comando es enviado de un servidor al otro para indicar que va a mandar informacion acerca de un email que se necesita ser enviado al contacto que se indica en el mismo. Despues a esto, el servidor que mando el comando, debe proseguir a enviar los datos de el email (sin esperar respuesta), de la siguiente forma:


	MAIL FROM username@server
	MAIL SUBJECT text
	MAIL BODY text

y despues concluir con el comando:


	END SEND MAIL

Si no hay problema con el email, entonces el servidor debe contestar con un


	OK SEND MAIL

En el caso de que el contacto no exista, el servidor debe enviar el mensaje de error:


	SEND ERROR 201 contact@server

el cual representa el tipo de error "unknown contact". En el caso de otros errores, el servidor debe mandar una de estas posibles instrucciones de error.


	SEND ERROR 202 
	SEND ERROR 203 
	SEND ERROR 204 

En donde 202 es el tipo de error "no sender (from)", 203 es "no subject" y 204 es "no body".

El servidor que recibio la notificacion de envio de email, debe guardar el email en la base de datos, el cual sera mandado al usuario en el momento en el que el cliente lo solicite.

CHECK CONTACT contact@server
Este es el comando que envia un server a otro cuando quiere chequear que un contacto exista. Al recibir este mensaje, el servidor debe chequear sus usuarios locales, y si el contacto si existe enviar de regreso:


	OK CHECK CONTACT contact@server

Si el contacto no existe entonces mandar el warning:


	CHECK ERROR 205

el cual representa el tipo de error "unknown contact", y si el server que aparece en "contact@server" de la instruccion, no es este server, entonces se debe mandar el error:


	CHECK ERROR 206

el cual representa el tipo de error "not this server".

COMUNICACION SERVIDOR - DNS

Para que esta aplicacion funcione correctamente , y los servidores puedan conectarse entre si, va existir un programa (hecho por nosotros, no por ustedes) que va a tener la tarea de un DNS. Este programa llevara el registro de los servidores que esten "online" y sus ips, para que los servidores puedan solicitarla cuando lo necesiten.
Para llevar la tabla actualizada, se necesita que cuando el servidor empiece a ejecutarse, mande un mensaje al programa DNS (cuyo ip debe poderse ingresar en el programa servidor), avisandole que ahora esta en linea, y registrando su ip. La instruccion para esto es:


	ONLINE servername ip

a lo que el DNS le contestara un


	OK ONLINE servername

Si el servidor que manda esta instruccion, ya existe en la tabla de el DNS, entonces se modificara el ip en la tabla (si el ip que se mando en la instruccion, es diferente al que estaba en la tabla). A la hora de que el servidor se "apague", debe mandar al DNS la instruccion


	OFFLINE servername

a lo que el DNS contestara


	OK OFFLINE servername

Para obtener el ip-table de los servidores en cualquier momento, el server debe mandar al DNS una solicitud, con la instruccion:


	GETIPTABLE

a lo que el DNS contestara con un listado de servidores con sus ips, utilizando


	OK IPTABLE servername ip 	o
	OK IPTABLE servername ip *

en donde el "*" significa que ese server es el ultimo en la lista/tabla

Los errores que manejara(devolvera) el DNS son:


	ONLINE ERROR 301

Error que indica un "ip invalido".


	OFFLINE ERROR 302

Error que indica que el servidor que esta haciendo offline, no existe en la tabla (ya sea nunca hizo un online, o ya habia hecho offline antes).


	GETIPTABLE ERROR 303

Que representa un warning de que no hay servidores en la tabla.

OTRAS INDICACIONES

INVALID COMMAND
El error que cualquiera de los programas envia, si la instruccion que se le envio es invalida, debe ser:


	INVALID COMMAND ERROR

PUERTOS
El servidor debe escuchar en dos puertos diferentes, en el puerto 1400 para los clientes, y en el puerto 1500 para los servidores.
El cliente siempre escuchara en el puerto 1400. El DNS escuchara en el puerto 1200.

FUNCIONES DEL SERVIDOR
El servidor tiene como funcion principal esperar solicitudes de clientes y servidores. Sin embargo, tambien debe tener funciones para el usuario que lo esta corriendo (server administrator).
Una de las funciones que debe permitir el servidor es ingresar el ip de DNS, el cual se mantendra mientras el servidor este ejecutansose.

SOLO se pueden agregar usuarios al servidor por medio del mismo servidor, no por medio de clientes, por lo que debe tener esta opcion.

Tambien debe tener la funcion de poder cambiar los puertos en donde se escucha.

LOG DE COMANDOS:
Tanto el servidor como el cliente tiene que escribir los comandos que manda y escucha en la consola.

INTERFAZ GRAFICA:
Tanto el programa cliente, como el programa servidor deben tener interfaz grafica.

BASE DE DATOS:
Dado que el servidor debe mantener datos como: usuarios, emails, tabla de servidores, etc, usted DEBE de utilizar una base de datos para guardar estos. De tal forma que cuando el servidor se ejecute, lea los datos de dicha base de datos. El cliente deberia utilizar esta base de datos para guardar los emails (ya leidos de el servidor) por usuarios.
La base de datos que usted puede utilizar es SQLite (http://www.sqlite.org/). Para el manejo de la base de datos se le provee la clase DB, la cual puede encontrar en este paquete. Este paquete contiene:

    La clase DB, en el archivo DB.class
    El Javadoc para esta clase (API)
    Una clase y una base de datos prueba. 

Para poder utilizar la clase, revise el API y la clase de prueba.

Si usted desea utilizar otra base de datos, puede hacerlo, utilizando otra libreria que le ayude a manejar lo puede hacer

PUNTOS EXTRA:
Los puntos extra los dejo a su criterio. Nosotros decidiremos si su trabajo extra merece puntos o no, asi que sea creativo.

ENTREGA:

Su proyecto es entregado por medio del GES y usted solo debe entregar un archivo llamado pj3-grupoN.zip (donde N es el numero de grupo que se les asigno). Dentro de ese archivo .zip deben ir todos los documentos y archivos que se le piden a continuacion, incluyendo los archivos/documentos extra que usted utilizo para la implementacion de su proyecto.

La entrega del proyecto sera personal, el dia que se les indico deben presentarse en la Universidad todos los integrantes del grupo, y traer lo siguiente:

    Su proyecto, es decir, todos los archivos .java que utilizo en el mismo. Debe venir preparado para mostrar el funcionamiento del mismo en red. (Computadoras, cables de red, etc) Cada uno de los procedimientos y funciones de su codigo deben estar debidamente comentariados. Asi como cada clase. (esto no quiere decir que excesivamente comentariadas)
    Un documento impreso en donde explique como implemento su proyecto, herramientas que utilizo, y todas las estructuras de datos que utilizo, en donde y para que.
    Un manual de usuario en donde indicara como utilizar su cliente y su servidor. 

GRUPOS:
Para recibir numero de grupo debe mandar un email a cc2fisicc@galileo.edu (o al correo de su profesor de curso), indicando los nombres de sus integrantes, de que seccion son, e indicando tambien quienes son los encargados del cliente, y quienes del servidor. 
